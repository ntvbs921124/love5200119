<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
  #fullscreen-btn { 
    position: absolute; top: 20px; right: 20px; 
    padding: 8px 15px; background: rgba(255,255,255,0.1); 
    color: white; border: 1px solid rgba(255,255,255,0.3); 
    border-radius: 4px; cursor: pointer; pointer-events: auto;
    font-family: sans-serif; transition: 0.3s;
  }
  #fullscreen-btn:hover { background: rgba(255,255,255,0.2); }
  video { display: none; } /* 隐藏原始视频 */
</style>

<div id="ui-layer">
  <button id="fullscreen-btn">全屏模式</button>
</div>
<video id="input-video"></video>

<script>
/**
 * 配置与状态管理
 */
const CONFIG = {
  particleCount: 5000,
  fontSize: 40,
  fontColor: 0xffffff,
  colors: [0xff3366, 0xffffff, 0x00ffcc]
};

let scene, camera, renderer, particles, clock;
let currentGesture = -1; // -1: 无, 0: 握拳, 1-3: 数字, 5: 张开
let targetPositions = [];
let particleSystem;
let extraElements = []; // 存储气球和鲜花

/**
 * 核心逻辑：粒子与文字转换
 */
function createTextPoints(text) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 400;
  canvas.height = 200;
  ctx.fillStyle = 'white';
  ctx.font = `bold ${CONFIG.fontSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.fillText(text, 200, 100);

  const imageData = ctx.getImageData(0, 0, 400, 200).data;
  const points = [];
  for (let y = 0; y < 200; y += 3) {
    for (let x = 0; x < 400; x += 3) {
      if (imageData[(y * 400 + x) * 4 + 3] > 128) {
        points.push(new THREE.Vector3((x - 200) * 0.1, (100 - y) * 0.1, 0));
      }
    }
  }
  return points;
}

/**
 * 场景初始化
 */
function initScene() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 25;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // 初始化基础粒子
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(CONFIG.particleCount * 3);
  for (let i = 0; i < CONFIG.particleCount * 3; i++) {
    positions[i] = (Math.random() - 0.5) * 50;
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  
  const material = new THREE.PointsMaterial({
    size: 0.15,
    color: 0xffffff,
    transparent: true,
    blending: THREE.AdditiveBlending
  });

  particleSystem = new THREE.Points(geometry, material);
  scene.add(particleSystem);
  
  clock = new THREE.Clock();
}

/**
 * 交互反馈：气球与鲜花生成
 */
function spawnCelebration() {
  clearExtras();
  for(let i=0; i<30; i++) {
    const isFlower = Math.random() > 0.5;
    const geometry = isFlower ? new THREE.TorusGeometry(0.3, 0.1, 8, 16) : new THREE.SphereGeometry(0.5, 16, 16);
    const material = new THREE.MeshBasicMaterial({ color: CONFIG.colors[Math.floor(Math.random()*3)] });
    const mesh = new THREE.Mesh(geometry, material);
    
    mesh.position.set((Math.random()-0.5)*40, -15, (Math.random()-0.5)*10);
    mesh.userData = { speed: 0.1 + Math.random() * 0.2, rot: Math.random() * 0.05 };
    scene.add(mesh);
    extraElements.push(mesh);
  }
}

function clearExtras() {
  extraElements.forEach(el => scene.remove(el));
  extraElements = [];
}

/**
 * 手势逻辑映射
 */
function updateGestureEffect(gesture) {
  if (gesture === currentGesture) return;
  currentGesture = gesture;

  let points = [];
  if (gesture >= 1 && gesture <= 3) {
    clearExtras();
    points = createTextPoints(gesture.toString());
  } else if (gesture === 5) {
    points = createTextPoints("I ❤ U");
    spawnCelebration();
  } else if (gesture === 0) {
    clearExtras();
    points = []; // 握拳清空
  }

  targetPositions = points;
}

/**
 * 手势识别核心
 */
const videoElement = document.getElementById('input-video');
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults((results) => {
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    const landmarks = results.multiHandLandmarks[0];
    
    // 简易指尖计数逻辑
    const fingerTips = [8, 12, 16, 20];
    let count = 0;
    fingerTips.forEach(idx => {
      if (landmarks[idx].y < landmarks[idx - 2].y) count++;
    });
    // 大拇指检测 (基于坐标相对于手掌中心)
    if (Math.abs(landmarks[4].x - landmarks[17].x) > 0.15) count++;

    // 握拳检测
    const isFist = landmarks[8].y > landmarks[6].y && landmarks[12].y > landmarks[10].y;

    if (isFist) updateGestureEffect(0);
    else updateGestureEffect(count);
  }
});

const cameraUtils = new Camera(videoElement, {
  onFrame: async () => { await hands.send({ image: videoElement }); },
  width: 640, height: 480
});
cameraUtils.start();

/**
 * 渲染循环
 */
function animate() {
  requestAnimationFrame(animate);
  const positions = particleSystem.geometry.attributes.position.array;

  // 粒子插值平滑移动
  for (let i = 0; i < CONFIG.particleCount; i++) {
    const i3 = i * 3;
    const target = targetPositions[i % targetPositions.length] || { x: (Math.random()-0.5)*100, y: -50, z: 0 };
    
    // 缓动算法: current += (target - current) * lerpFactor
    positions[i3] += (target.x - positions[i3]) * 0.1;
    positions[i3+1] += (target.y - positions[i3+1]) * 0.1;
    positions[i3+2] += (target.z - positions[i3+2]) * 0.1;
  }
  particleSystem.geometry.attributes.position.needsUpdate = true;

  // 气球/鲜花动画
  extraElements.forEach(el => {
    el.position.y += el.userData.speed;
    el.rotation.x += el.userData.rot;
    if(el.position.y > 20) el.position.y = -20;
  });

  renderer.render(scene, camera);
}

// 响应式设计
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// 全屏切换
document.getElementById('fullscreen-btn').addEventListener('click', () => {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
});

initScene();
animate();
</script>