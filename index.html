<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
  canvas { display: block; }
  #fullscreen-btn { 
    position: fixed; top: 25px; right: 25px; z-index: 100;
    padding: 10px 20px; background: rgba(255, 255, 255, 0.05);
    color: rgba(255, 255, 255, 0.8); border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50px; cursor: pointer; backdrop-filter: blur(10px);
    font-size: 13px; letter-spacing: 1px; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }
  #fullscreen-btn:hover { background: rgba(255, 255, 255, 0.15); color: #fff; transform: scale(1.05); }
  video { display: none; }
</style>

<button id="fullscreen-btn">ENTER IMMERSIVE</button>
<video id="input-video"></video>

<script>
/**
 * 高级配置：增加粒子密度与色彩深度
 */
const PARAMS = {
  pCount: 8000,
  colors: [0x00ffff, 0xff00ff, 0xffff00], // 霓虹三原色
  heartColor: 0xff3366,
  lerpSpeed: 0.08,
  bloomScale: 1.2
};

let scene, camera, renderer, starSystem, clock;
let currentGesture = -1;
let targetPos = [];
let extraObjects = [];

/**
 * 视觉增强：创建发光纹理
 */
function createGlowTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 64;
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255,255,255,1)');
  gradient.addColorStop(0.2, 'rgba(255,255,255,0.5)');
  gradient.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);
  const tex = new THREE.CanvasTexture(canvas);
  return tex;
}

/**
 * 文字点云提取优化 (支持更细腻的形状)
 */
function getTextPoints(text, isLove = false) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 600; canvas.height = 300;
  ctx.fillStyle = 'white';
  ctx.font = `bold ${isLove ? 100 : 140}px Arial Black`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, 300, 150);

  const data = ctx.getImageData(0, 0, 600, 300).data;
  const pts = [];
  const step = 4; // 密度控制
  for (let y = 0; y < 300; y += step) {
    for (let x = 0; x < 600; x += step) {
      if (data[(y * 600 + x) * 4 + 3] > 128) {
        pts.push(new THREE.Vector3((x - 300) * 0.08, (150 - y) * 0.08, (Math.random()-0.5)*2));
      }
    }
  }
  return pts;
}

/**
 * 初始化华丽的3D环境
 */
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 30;

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // 粒子系统初始化
  const geo = new THREE.BufferGeometry();
  const posArray = new Float32Array(PARAMS.pCount * 3);
  const colorArray = new Float32Array(PARAMS.pCount * 3);

  for(let i=0; i<PARAMS.pCount; i++) {
    posArray[i*3] = (Math.random()-0.5)*100;
    posArray[i*3+1] = (Math.random()-0.5)*100;
    posArray[i*3+2] = (Math.random()-0.5)*100;
    
    const color = new THREE.Color(PARAMS.colors[i % 3]);
    colorArray[i*3] = color.r;
    colorArray[i*3+1] = color.g;
    colorArray[i*3+2] = color.b;
  }

  geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.35,
    map: createGlowTexture(),
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  starSystem = new THREE.Points(geo, mat);
  scene.add(starSystem);
  
  clock = new THREE.Clock();
}

/**
 * 庆典动效：水晶质感气球
 */
function spawnLux() {
  const colors = [0xff77aa, 0x77ffaa, 0x77aaff, 0xffcc33];
  for(let i=0; i<40; i++) {
    const geo = Math.random() > 0.3 ? new THREE.SphereGeometry(0.4, 12, 12) : new THREE.IcosahedronGeometry(0.5, 0);
    const mat = new THREE.MeshPhongMaterial({ 
      color: colors[Math.floor(Math.random()*colors.length)],
      emissive: 0x222222,
      specular: 0xffffff,
      shininess: 100,
      transparent: true,
      opacity: 0.7
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set((Math.random()-0.5)*50, -25 - Math.random()*20, (Math.random()-0.5)*10);
    mesh.userData = { vy: 0.08 + Math.random()*0.15, rs: Math.random()*0.02 };
    scene.add(mesh);
    extraObjects.push(mesh);
  }
  const light = new THREE.PointLight(0xff3366, 2, 50);
  light.position.set(0,0,5);
  scene.add(light);
  extraObjects.push(light);
}

/**
 * 手势与逻辑
 */
const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75 });

hands.onResults((res) => {
  if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
    const lm = res.multiHandLandmarks[0];
    let fingers = [lm[8], lm[12], lm[16], lm[20]].filter(f => f.y < lm[f === lm[8] ? 6 : (lm.indexOf(f)-2)].y).length;
    if (Math.abs(lm[4].x - lm[17].x) > 0.15) fingers++;

    const isFist = lm[8].y > lm[5].y && lm[12].y > lm[9].y && lm[16].y > lm[13].y;
    
    let nextG = isFist ? 0 : fingers;
    if(nextG !== currentGesture) {
      currentGesture = nextG;
      extraObjects.forEach(o => scene.remove(o));
      extraObjects = [];
      
      if(nextG === 5) {
        targetPos = getTextPoints("I ❤ U", true);
        spawnLux();
      } else if(nextG >= 1 && nextG <= 3) {
        targetPos = getTextPoints(nextG.toString());
      } else {
        targetPos = []; // 握拳重置
      }
    }
  }
});

const cam = new Camera(document.getElementById('input-video'), {
  onFrame: async () => await hands.send({image: document.getElementById('input-video')}),
  width: 640, height: 480
});
cam.start();

function animate() {
  requestAnimationFrame(animate);
  const time = clock.getElapsedTime();
  const pos = starSystem.geometry.attributes.position.array;

  for (let i = 0; i < PARAMS.pCount; i++) {
    const i3 = i * 3;
    let tx, ty, tz;

    if (targetPos.length > 0) {
      const target = targetPos[i % targetPos.length];
      tx = target.x; ty = target.y; tz = target.z;
    } else {
      // 待机状态：优雅的星云旋转
      tx = Math.cos(time * 0.3 + i) * (20 + Math.sin(i) * 5);
      ty = Math.sin(time * 0.5 + i) * (15 + Math.cos(i) * 5);
      tz = Math.sin(time * 0.2) * 10;
    }

    pos[i3] += (tx - pos[i3]) * PARAMS.lerpSpeed;
    pos[i3+1] += (ty - pos[i3+1]) * PARAMS.lerpSpeed;
    pos[i3+2] += (tz - pos[i3+2]) * PARAMS.lerpSpeed;
  }
  
  starSystem.geometry.attributes.position.needsUpdate = true;
  starSystem.rotation.y = Math.sin(time * 0.1) * 0.2; // 微弱的整体晃动感

  extraObjects.forEach(obj => {
    if(obj.isMesh) {
      obj.position.y += obj.userData.vy;
      obj.rotation.y += obj.userData.rs;
      if(obj.position.y > 30) obj.position.y = -30;
    }
  });

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('fullscreen-btn').onclick = () => {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
};

init();
animate();
</script>
